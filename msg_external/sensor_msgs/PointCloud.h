/* Auto-generated by genmsg_cpp for file /home/ckilner/ros/stacks/common_msgs/sensor_msgs/msg/PointCloud.msg */
#ifndef SENSOR_MSGS_MESSAGE_POINTCLOUD_H
#define SENSOR_MSGS_MESSAGE_POINTCLOUD_H
#include <string>
#include <vector>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/message.h"
#include "ros/time.h"

#include "roslib/Header.h"
#include "geometry_msgs/Point32.h"
#include "sensor_msgs/ChannelFloat32.h"

namespace sensor_msgs
{
template <class ContainerAllocator>
struct PointCloud_ : public ros::Message
{
  typedef PointCloud_<ContainerAllocator> Type;

  PointCloud_()
  : header()
  , points()
  , channels()
  {
  }

  PointCloud_(const ContainerAllocator& _alloc)
  : header(_alloc)
  , points(_alloc)
  , channels(_alloc)
  {
  }

  typedef  ::roslib::Header_<ContainerAllocator>  _header_type;
   ::roslib::Header_<ContainerAllocator>  header;

  typedef std::vector< ::geometry_msgs::Point32_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::geometry_msgs::Point32_<ContainerAllocator> >::other >  _points_type;
  std::vector< ::geometry_msgs::Point32_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::geometry_msgs::Point32_<ContainerAllocator> >::other >  points;

  typedef std::vector< ::sensor_msgs::ChannelFloat32_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::sensor_msgs::ChannelFloat32_<ContainerAllocator> >::other >  _channels_type;
  std::vector< ::sensor_msgs::ChannelFloat32_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::sensor_msgs::ChannelFloat32_<ContainerAllocator> >::other >  channels;


  ROSCPP_DEPRECATED uint32_t get_points_size() const { return (uint32_t)points.size(); }
  ROSCPP_DEPRECATED void set_points_size(uint32_t size) { points.resize((size_t)size); }
  ROSCPP_DEPRECATED void get_points_vec(std::vector< ::geometry_msgs::Point32_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::geometry_msgs::Point32_<ContainerAllocator> >::other > & vec) const { vec = this->points; }
  ROSCPP_DEPRECATED void set_points_vec(const std::vector< ::geometry_msgs::Point32_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::geometry_msgs::Point32_<ContainerAllocator> >::other > & vec) { this->points = vec; }
  ROSCPP_DEPRECATED uint32_t get_channels_size() const { return (uint32_t)channels.size(); }
  ROSCPP_DEPRECATED void set_channels_size(uint32_t size) { channels.resize((size_t)size); }
  ROSCPP_DEPRECATED void get_channels_vec(std::vector< ::sensor_msgs::ChannelFloat32_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::sensor_msgs::ChannelFloat32_<ContainerAllocator> >::other > & vec) const { vec = this->channels; }
  ROSCPP_DEPRECATED void set_channels_vec(const std::vector< ::sensor_msgs::ChannelFloat32_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::sensor_msgs::ChannelFloat32_<ContainerAllocator> >::other > & vec) { this->channels = vec; }
private:
  static const char* __s_getDataType_() { return "sensor_msgs/PointCloud"; }
public:
  ROSCPP_DEPRECATED static const std::string __s_getDataType() { return __s_getDataType_(); }

  ROSCPP_DEPRECATED const std::string __getDataType() const { return __s_getDataType_(); }

private:
  static const char* __s_getMD5Sum_() { return "d8e9c3f5afbdd8a130fd1d2763945fca"; }
public:
  ROSCPP_DEPRECATED static const std::string __s_getMD5Sum() { return __s_getMD5Sum_(); }

  ROSCPP_DEPRECATED const std::string __getMD5Sum() const { return __s_getMD5Sum_(); }

private:
  static const char* __s_getMessageDefinition_() { return "#This message holds a collection of 3d points, plus optional additional information about each point.\n\
#Each Point32 should be interpreted as a 3d point in the frame given in the header\n\
\n\
Header header\n\
geometry_msgs/Point32[] points  #Array of 3d points\n\
ChannelFloat32[] channels       #Each channel should have the same number of elements as points array, and the data in each channel should correspond 1:1 with each point\n\
\n\
================================================================================\n\
MSG: roslib/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.secs: seconds (stamp_secs) since epoch\n\
# * stamp.nsecs: nanoseconds since stamp_secs\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
\n\
================================================================================\n\
MSG: geometry_msgs/Point32\n\
# This contains the position of a point in free space(with 32 bits of precision).\n\
# It is recommeded to use Point wherever possible instead of Point32.  \n\
# \n\
# This recommendation is to promote interoperability.  \n\
#\n\
# This message is designed to take up less space when sending\n\
# lots of points at once, as in the case of a PointCloud.  \n\
\n\
float32 x\n\
float32 y\n\
float32 z\n\
================================================================================\n\
MSG: sensor_msgs/ChannelFloat32\n\
#This message is used by the PointCloud message to hold optional data associated with each point in the cloud\n\
#The length of the values array should be the same as the length of the points array in the PointCloud, and each value should be associated with the corresponding point\n\
\n\
string name       #channel name should give semantics of the channel (e.g. \"intensity\" instead of \"value\")\n\
float32[] values  #values array should have same number of elements as the associated PointCloud\n\
\n\
"; }
public:
  ROSCPP_DEPRECATED static const std::string __s_getMessageDefinition() { return __s_getMessageDefinition_(); }

  ROSCPP_DEPRECATED const std::string __getMessageDefinition() const { return __s_getMessageDefinition_(); }

  ROSCPP_DEPRECATED virtual uint8_t *serialize(uint8_t *write_ptr, uint32_t seq) const
  {
    ros::serialization::OStream stream(write_ptr, 1000000000);
    ros::serialization::serialize(stream, header);
    ros::serialization::serialize(stream, points);
    ros::serialization::serialize(stream, channels);
    return stream.getData();
  }

  ROSCPP_DEPRECATED virtual uint8_t *deserialize(uint8_t *read_ptr)
  {
    ros::serialization::IStream stream(read_ptr, 1000000000);
    ros::serialization::deserialize(stream, header);
    ros::serialization::deserialize(stream, points);
    ros::serialization::deserialize(stream, channels);
    return stream.getData();
  }

  ROSCPP_DEPRECATED virtual uint32_t serializationLength() const
  {
    uint32_t size = 0;
    size += ros::serialization::serializationLength(header);
    size += ros::serialization::serializationLength(points);
    size += ros::serialization::serializationLength(channels);
    return size;
  }

  typedef boost::shared_ptr< ::sensor_msgs::PointCloud_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::sensor_msgs::PointCloud_<ContainerAllocator>  const> ConstPtr;
}; // struct PointCloud
typedef  ::sensor_msgs::PointCloud_<std::allocator<void> > PointCloud;

typedef boost::shared_ptr< ::sensor_msgs::PointCloud> PointCloudPtr;
typedef boost::shared_ptr< ::sensor_msgs::PointCloud const> PointCloudConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::sensor_msgs::PointCloud_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::sensor_msgs::PointCloud_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace sensor_msgs

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator>
struct MD5Sum< ::sensor_msgs::PointCloud_<ContainerAllocator> > {
  static const char* value() 
  {
    return "d8e9c3f5afbdd8a130fd1d2763945fca";
  }

  static const char* value(const  ::sensor_msgs::PointCloud_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0xd8e9c3f5afbdd8a1ULL;
  static const uint64_t static_value2 = 0x30fd1d2763945fcaULL;
};

template<class ContainerAllocator>
struct DataType< ::sensor_msgs::PointCloud_<ContainerAllocator> > {
  static const char* value() 
  {
    return "sensor_msgs/PointCloud";
  }

  static const char* value(const  ::sensor_msgs::PointCloud_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::sensor_msgs::PointCloud_<ContainerAllocator> > {
  static const char* value() 
  {
    return "#This message holds a collection of 3d points, plus optional additional information about each point.\n\
#Each Point32 should be interpreted as a 3d point in the frame given in the header\n\
\n\
Header header\n\
geometry_msgs/Point32[] points  #Array of 3d points\n\
ChannelFloat32[] channels       #Each channel should have the same number of elements as points array, and the data in each channel should correspond 1:1 with each point\n\
\n\
================================================================================\n\
MSG: roslib/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.secs: seconds (stamp_secs) since epoch\n\
# * stamp.nsecs: nanoseconds since stamp_secs\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
\n\
================================================================================\n\
MSG: geometry_msgs/Point32\n\
# This contains the position of a point in free space(with 32 bits of precision).\n\
# It is recommeded to use Point wherever possible instead of Point32.  \n\
# \n\
# This recommendation is to promote interoperability.  \n\
#\n\
# This message is designed to take up less space when sending\n\
# lots of points at once, as in the case of a PointCloud.  \n\
\n\
float32 x\n\
float32 y\n\
float32 z\n\
================================================================================\n\
MSG: sensor_msgs/ChannelFloat32\n\
#This message is used by the PointCloud message to hold optional data associated with each point in the cloud\n\
#The length of the values array should be the same as the length of the points array in the PointCloud, and each value should be associated with the corresponding point\n\
\n\
string name       #channel name should give semantics of the channel (e.g. \"intensity\" instead of \"value\")\n\
float32[] values  #values array should have same number of elements as the associated PointCloud\n\
\n\
";
  }

  static const char* value(const  ::sensor_msgs::PointCloud_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct HasHeader< ::sensor_msgs::PointCloud_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::sensor_msgs::PointCloud_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.header);
    stream.next(m.points);
    stream.next(m.channels);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct PointCloud_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::sensor_msgs::PointCloud_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::sensor_msgs::PointCloud_<ContainerAllocator> & v) 
  {
    s << indent << "header: ";
s << std::endl;
    Printer< ::roslib::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "points[]" << std::endl;
    for (size_t i = 0; i < v.points.size(); ++i)
    {
      s << indent << "  points[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::geometry_msgs::Point32_<ContainerAllocator> >::stream(s, indent + "    ", v.points[i]);
    }
    s << indent << "channels[]" << std::endl;
    for (size_t i = 0; i < v.channels.size(); ++i)
    {
      s << indent << "  channels[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::sensor_msgs::ChannelFloat32_<ContainerAllocator> >::stream(s, indent + "    ", v.channels[i]);
    }
  }
};


} // namespace message_operations
} // namespace ros

#endif // SENSOR_MSGS_MESSAGE_POINTCLOUD_H

