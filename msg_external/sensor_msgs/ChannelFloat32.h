/* Auto-generated by genmsg_cpp for file /home/ckilner/ros/stacks/common_msgs/sensor_msgs/msg/ChannelFloat32.msg */
#ifndef SENSOR_MSGS_MESSAGE_CHANNELFLOAT32_H
#define SENSOR_MSGS_MESSAGE_CHANNELFLOAT32_H
#include <string>
#include <vector>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/message.h"
#include "ros/time.h"


namespace sensor_msgs
{
template <class ContainerAllocator>
struct ChannelFloat32_ : public ros::Message
{
  typedef ChannelFloat32_<ContainerAllocator> Type;

  ChannelFloat32_()
  : name()
  , values()
  {
  }

  ChannelFloat32_(const ContainerAllocator& _alloc)
  : name(_alloc)
  , values(_alloc)
  {
  }

  typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _name_type;
  std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  name;

  typedef std::vector<float, typename ContainerAllocator::template rebind<float>::other >  _values_type;
  std::vector<float, typename ContainerAllocator::template rebind<float>::other >  values;


  ROSCPP_DEPRECATED uint32_t get_values_size() const { return (uint32_t)values.size(); }
  ROSCPP_DEPRECATED void set_values_size(uint32_t size) { values.resize((size_t)size); }
  ROSCPP_DEPRECATED void get_values_vec(std::vector<float, typename ContainerAllocator::template rebind<float>::other > & vec) const { vec = this->values; }
  ROSCPP_DEPRECATED void set_values_vec(const std::vector<float, typename ContainerAllocator::template rebind<float>::other > & vec) { this->values = vec; }
private:
  static const char* __s_getDataType_() { return "sensor_msgs/ChannelFloat32"; }
public:
  ROSCPP_DEPRECATED static const std::string __s_getDataType() { return __s_getDataType_(); }

  ROSCPP_DEPRECATED const std::string __getDataType() const { return __s_getDataType_(); }

private:
  static const char* __s_getMD5Sum_() { return "3d40139cdd33dfedcb71ffeeeb42ae7f"; }
public:
  ROSCPP_DEPRECATED static const std::string __s_getMD5Sum() { return __s_getMD5Sum_(); }

  ROSCPP_DEPRECATED const std::string __getMD5Sum() const { return __s_getMD5Sum_(); }

private:
  static const char* __s_getMessageDefinition_() { return "#This message is used by the PointCloud message to hold optional data associated with each point in the cloud\n\
#The length of the values array should be the same as the length of the points array in the PointCloud, and each value should be associated with the corresponding point\n\
\n\
string name       #channel name should give semantics of the channel (e.g. \"intensity\" instead of \"value\")\n\
float32[] values  #values array should have same number of elements as the associated PointCloud\n\
\n\
"; }
public:
  ROSCPP_DEPRECATED static const std::string __s_getMessageDefinition() { return __s_getMessageDefinition_(); }

  ROSCPP_DEPRECATED const std::string __getMessageDefinition() const { return __s_getMessageDefinition_(); }

  ROSCPP_DEPRECATED virtual uint8_t *serialize(uint8_t *write_ptr, uint32_t seq) const
  {
    ros::serialization::OStream stream(write_ptr, 1000000000);
    ros::serialization::serialize(stream, name);
    ros::serialization::serialize(stream, values);
    return stream.getData();
  }

  ROSCPP_DEPRECATED virtual uint8_t *deserialize(uint8_t *read_ptr)
  {
    ros::serialization::IStream stream(read_ptr, 1000000000);
    ros::serialization::deserialize(stream, name);
    ros::serialization::deserialize(stream, values);
    return stream.getData();
  }

  ROSCPP_DEPRECATED virtual uint32_t serializationLength() const
  {
    uint32_t size = 0;
    size += ros::serialization::serializationLength(name);
    size += ros::serialization::serializationLength(values);
    return size;
  }

  typedef boost::shared_ptr< ::sensor_msgs::ChannelFloat32_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::sensor_msgs::ChannelFloat32_<ContainerAllocator>  const> ConstPtr;
}; // struct ChannelFloat32
typedef  ::sensor_msgs::ChannelFloat32_<std::allocator<void> > ChannelFloat32;

typedef boost::shared_ptr< ::sensor_msgs::ChannelFloat32> ChannelFloat32Ptr;
typedef boost::shared_ptr< ::sensor_msgs::ChannelFloat32 const> ChannelFloat32ConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::sensor_msgs::ChannelFloat32_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::sensor_msgs::ChannelFloat32_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace sensor_msgs

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator>
struct MD5Sum< ::sensor_msgs::ChannelFloat32_<ContainerAllocator> > {
  static const char* value() 
  {
    return "3d40139cdd33dfedcb71ffeeeb42ae7f";
  }

  static const char* value(const  ::sensor_msgs::ChannelFloat32_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x3d40139cdd33dfedULL;
  static const uint64_t static_value2 = 0xcb71ffeeeb42ae7fULL;
};

template<class ContainerAllocator>
struct DataType< ::sensor_msgs::ChannelFloat32_<ContainerAllocator> > {
  static const char* value() 
  {
    return "sensor_msgs/ChannelFloat32";
  }

  static const char* value(const  ::sensor_msgs::ChannelFloat32_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::sensor_msgs::ChannelFloat32_<ContainerAllocator> > {
  static const char* value() 
  {
    return "#This message is used by the PointCloud message to hold optional data associated with each point in the cloud\n\
#The length of the values array should be the same as the length of the points array in the PointCloud, and each value should be associated with the corresponding point\n\
\n\
string name       #channel name should give semantics of the channel (e.g. \"intensity\" instead of \"value\")\n\
float32[] values  #values array should have same number of elements as the associated PointCloud\n\
\n\
";
  }

  static const char* value(const  ::sensor_msgs::ChannelFloat32_<ContainerAllocator> &) { return value(); } 
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::sensor_msgs::ChannelFloat32_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.name);
    stream.next(m.values);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct ChannelFloat32_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::sensor_msgs::ChannelFloat32_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::sensor_msgs::ChannelFloat32_<ContainerAllocator> & v) 
  {
    s << indent << "name: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.name);
    s << indent << "values[]" << std::endl;
    for (size_t i = 0; i < v.values.size(); ++i)
    {
      s << indent << "  values[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.values[i]);
    }
  }
};


} // namespace message_operations
} // namespace ros

#endif // SENSOR_MSGS_MESSAGE_CHANNELFLOAT32_H

